/** Added page lock for pins and moved the token link to bar 1.
*/
on('ready', function() {
    const clearURL = 'https://s3.amazonaws.com/files.d20.io/images/4277467/iQYjFOsYC5JsuOPUCI9RGA/thumb.png?1401938659';

    if (!state.MapPins) {
        state.MapPins = { locks: {} };
    }

    function toggleLock(pageid) {
        state.MapPins.locks[pageid] = !state.MapPins.locks[pageid];
        let status = state.MapPins.locks[pageid] ? 'locked' : 'unlocked';
        sendChat('Map Pins', `/w gm Map Pins on this page are now **${status}**.`);
    }

    function updateMapPinHandout(content) {
        let handout = findObjs({ type: 'handout', name: 'Map Pin' })[0];
        if (!handout) {
            handout = createObj('handout', {
                name: 'Map Pin',
                inplayerjournals: ''
            });
        }
        let parsedContent = parseContent(content);
        handout.set('notes', parsedContent);
        let handoutID = handout.id;
        sendChat('Map Pins', `/w gm Map Pin handout updated. [Open Map Pin](https://journal.roll20.net/handout/${handoutID})`);
    }

    function parseContent(content) {
        // First, decode the URL-encoded content
        let decodedContent = decodeURIComponent(content);

        // Now, parse for image links and render them in HTML
        return decodedContent.replace(/!\[([^\]]*)\]\((https?:\/\/[^\)]+)\)/g, '<img src="$2" alt="$1" style="max-width: 100%;" />');
    }

    function addDetailsAction(character) {
        let ability = findObjs({ type: 'ability', characterid: character.id, name: 'Details' })[0];
        if (!ability) {
            createObj('ability', {
                characterid: character.id,
                name: 'Details',
                action: "!showMapPin",
                istokenaction: true
            });
        }
    }

    function createMirrorToken(pinToken) {
        let mirror = createObj('graphic', {
            name: 'Map Pin Mirror',
            imgsrc: clearURL,
            layer: 'objects',
            left: pinToken.get('left'),
            top: pinToken.get('top'),
            width: pinToken.get('width'),
            height: pinToken.get('height'),
            controlledby: pinToken.get('controlledby'),
            represents: pinToken.get('represents'),
            statusmarkers: '',
            pageid: pinToken.get('pageid'),
            bar1_value: pinToken.id // Store GM pin ID in Bar 1
        });
        
        if (mirror) {
            setTimeout(() => {
                pinToken.set('bar1_value', mirror.id); // Store Mirror token ID in Bar 1
            }, 500);
        }
    }

    function deleteMirrorToken(pinToken) {
        let mirrorID = pinToken.get('bar1_value');
        let mirror = getObj('graphic', mirrorID);
        if (mirror) {
            mirror.remove();
        }
    }

    function moveLinkedTokens(obj) {
        let linkedID = obj.get('bar1_value');
        if (!linkedID) return;
        
        let linkedToken = getObj('graphic', linkedID);
        if (!linkedToken) return;
        
        let pageid = obj.get('pageid');
        if (state.MapPins.locks[pageid]) {
            obj.set({
                left: linkedToken.get('left'),
                top: linkedToken.get('top')
            });
            sendChat('Map Pins', '/w gm Map Pins are locked on this page! Unlock with `!lockMapPins`.');
        } else {
            linkedToken.set({
                left: obj.get('left'),
                top: obj.get('top')
            });
        }
    }

    function setupMapPin(token) {
        if (token.get('layer') !== 'gmlayer') return;
        let characterID = token.get('represents');
        if (!characterID) return;
        let character = getObj('character', characterID);
        if (!character || character.get('name') !== 'Pins') return;
        
        if (token.get('name') !== 'Pins') {
            token.set('name', 'Pins');
        }
        
        token.set({ represents: character.id });
        addDetailsAction(character);
        createMirrorToken(token);
    }

    on('chat:message', function(msg) {
        if (msg.type !== 'api') return;

        if (msg.content === '!lockMapPins') {
            let pageid = Campaign().get('playerpageid');
            toggleLock(pageid);
        }
        
        if (msg.content === '!deleteMapPin') {
            let selected = msg.selected;
            if (!selected || selected.length === 0) {
                sendChat('Map Pins', 'Please select a Map Pin token to delete!');
                return;
            }
            
            let pinToken = getObj('graphic', selected[0]._id);
            if (!pinToken) {
                sendChat('Map Pins', 'Selected token is not valid!');
                return;
            }
            
            deleteMirrorToken(pinToken);
            pinToken.remove();
            sendChat('Map Pins', 'Both the Map Pin and its mirror token have been deleted.');
        }
        
        if (msg.content === '!showMapPin') {
            let player = getObj('player', msg.playerid);
            let selected = msg.selected;
            if (!selected || selected.length === 0) {
                sendChat('Map Pins', `/w ${player.get('displayname')} No pin selected!`);
                return;
            }
            
            let mirrorToken = getObj('graphic', selected[0]._id);
            if (!mirrorToken) return;
            
            let gmPinID = mirrorToken.get('bar1_value');
            let gmPin = getObj('graphic', gmPinID);
            if (!gmPin) return;
            
            let gmNotes = gmPin.get('gmnotes'); // Ensure GM Notes are being fetched
            if (!gmNotes) {
                gmNotes = 'No details available.';
            }
            updateMapPinHandout(gmNotes); // Now updating handout with GM Notes
        }
    });

    on('add:graphic', setupMapPin);
    on('remove:graphic', deleteMirrorToken);
    on('change:graphic', moveLinkedTokens);
});


